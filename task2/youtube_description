Легкая часть (достаточно на "хор")

Задача заключается в работе с данными о трендах на YouTube. В этом вам поможет библиотека seaborn, которая была рассмотрена на одной из последних лекций.

Задача состоит из 7 пунктов, под каждый из которых предусмотрена соответствующая функция в классе YouTube:

Часть I. Подготовка данных

Скачайте файл RUvideos_short.csv с данными о видео в российском сегменте Youtube с 14 ноября по 21 ноября 2017 года. Полная версия данных доступна на kaggle.
Прочитайте данные с помощью библиотеки pandas. В колонке trending_date записана дата. При чтении таблицы распознайте ее правильным образом.

Замечание. Часто считывание дат — головная боль аналитика.

Верните считанную таблицу с колонкой trending_date типа datetime64
В таблице много лишних данных. Оставьте следующие столбцы:
trending_date 
−
− дата в формате год-день-месяц;
category_id 
−
− категория видео (названия приведены в файле RU_category_id.json, но в этой задаче они не пригодятся);
views 
−
− количество просмотров видео;
likes 
−
− количество лайков;
dislikes 
−
− количество дислайков;
comment_count 
−
− количество комментариев.
Из даты оставьте только день. Для этого можно пройтись циклом по всем датам и взять поле day у объекта даты. Верните получившуюся таблицу.

Часть II. Некоторая визуализация

Постройте ящики с усами на каждый день по количеству просмотров.
Насколько хороший получился график в прошлом пункте? Исправьте этот недостаток, установив некоторое значение.
Постройте jointplot по всем данным для количества просмотров по горизонтальной оси и количества лайков по вертикальной.
Насколько информативен график из прошлого пункта? Исправьте этот недостаток.
Шаблон решения:


from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.figure import Figure
import typing as tp


class YouTube:
    def __init__(self, path_to_df: str = "RUvideos_short.csv"):
        self.df = ...

    def task1(self) -> pd.DataFrame:
        return ...

    def task2(self) -> pd.DataFrame:
        return ...

    def task3(self) -> Figure:
        ...
        return plt.gcf()

    def task4(self) -> Figure:
        ...
        return plt.gcf()

    def task5(self) -> Figure:
        ...
        return plt.gcf()

    def task6(self) -> Figure:
        ...
        return plt.gcf()
Присылать нужно только код класса с подключением необходимых библиотек. Использовать библиотеки, которых нет в шаблоне, запрещается.
Во время тестирования создается только один объект класса решения. Все подзадачи запускаются по порядку.
Все функции для пунктов с графиками должны возвращать matplotlib.figure.Figure, на котором рисовался график. В шаблоне уже есть пример как это сделать через plt.gcf(), но при этом нельзя вызывать plt.show(), иначе холст сбросится и на проверку пойдёт пустой.
Решение будет протестировано на двух наборах тестов. В случае ошибок на первом наборе вы сможете увидеть данные теста, данные вторых тестов скрыты. Итоговые баллы выставляются за каждый пройденный тест.

